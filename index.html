<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Game Board</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="board">
    <!-- Board will be generated by script below -->
  </div>
  <div class="controls">
    <button id="placeWallBtn" disabled>Place Wall</button>
    <div id="gameStatus"></div>
  </div>
  <script>
    const board = document.querySelector('.board');
    const size = 12;
    let squareCount = 1;
    let wallCount = 1;
    // Game state
    const squares = [];
    const walls = [];
    const players = [
      { id: 1, color: '#e74c3c', pieces: [], name: 'Player 1' },
      { id: 2, color: '#27ae60', pieces: [], name: 'Player 2' }
    ];
    let currentPlayer = Math.floor(Math.random() * 2); // Random start
    let phase = 'placement'; // 'placement', 'move', 'wall', 'end'
    let placedPieces = 0;
    let selectedPiece = null;
    let moveCount = 0;
    let lastMovedPiece = null;
    let wallMode = false;
    let winner = null;

    // Build board and track squares/walls
    for (let row = 0; row < size * 2 - 1; row++) {
      const rowDiv = document.createElement('div');
      rowDiv.className = 'board-row';
      for (let col = 0; col < size * 2 - 1; col++) {
        if (row % 2 === 0 && col % 2 === 0) {
          // Square
          const sq = document.createElement('div');
          sq.className = 'square';
          sq.textContent = `s${squareCount}`;
          sq.dataset.square = squareCount;
          sq.dataset.row = row;
          sq.dataset.col = col;
          sq.addEventListener('click', () => onSquareClick(sq));
          squares.push(sq);
          rowDiv.appendChild(sq);
          squareCount++;
        } else if (row % 2 === 0 && col % 2 === 1) {
          // Vertical wall
          const wall = document.createElement('div');
          wall.className = 'wall wall-vertical';
          wall.textContent = `w${wallCount}`;
          wall.dataset.wall = wallCount;
          wall.dataset.row = row;
          wall.dataset.col = col;
          wall.dataset.active = 'false';
          wall.addEventListener('click', () => onWallClick(wall));
          walls.push(wall);
          rowDiv.appendChild(wall);
          wallCount++;
        } else if (row % 2 === 1 && col % 2 === 0) {
          // Horizontal wall
          const wall = document.createElement('div');
          wall.className = 'wall wall-horizontal';
          wall.textContent = `w${wallCount}`;
          wall.dataset.wall = wallCount;
          wall.dataset.row = row;
          wall.dataset.col = col;
          wall.dataset.active = 'false';
          wall.addEventListener('click', () => onWallClick(wall));
          walls.push(wall);
          rowDiv.appendChild(wall);
          wallCount++;
        } else {
          // Intersection
          const inter = document.createElement('div');
          inter.className = 'intersection';
          rowDiv.appendChild(inter);
        }
      }
      board.appendChild(rowDiv);
    }

    // Add controls
    const placeWallBtn = document.getElementById('placeWallBtn');
    const gameStatus = document.getElementById('gameStatus');
    placeWallBtn.addEventListener('click', () => {
      if (phase === 'move') {
        phase = 'wall';
        wallMode = true;
        placeWallBtn.disabled = true;
        updateStatus();
      }
    });

    function onSquareClick(sq) {
      if (phase === 'placement') {
        if (sq.querySelector('.piece')) return;
        const player = players[currentPlayer];
        if (player.pieces.length >= 2) return;
        placePiece(sq, player);
        placedPieces++;
        if (placedPieces < 4) {
          currentPlayer = 1 - currentPlayer;
        } else {
          phase = 'move';
          currentPlayer = Math.floor(Math.random() * 2); // Random start for moves
        }
        updateStatus();
      } else if (phase === 'move' && !wallMode) {
        // Select piece to move
        const piece = sq.querySelector('.piece');
        if (piece && +piece.dataset.player === players[currentPlayer].id) {
          selectedPiece = { sq, piece };
          highlightMoves(sq);
        } else if (selectedPiece && isValidMove(selectedPiece.sq, sq)) {
          movePiece(selectedPiece.sq, sq);
          selectedPiece = null;
          clearHighlights();
          lastMovedPiece = sq;
          wallMode = false;
          placeWallBtn.disabled = false;
          updateStatus();
        }
      }
    }

    function onWallClick(wall) {
      if (phase === 'wall' && wallMode && wall.dataset.active === 'false') {
        // Only allow adjacent to last moved piece
        if (lastMovedPiece && isAdjacentWall(lastMovedPiece, wall)) {
          wall.dataset.active = 'true';
          wall.classList.add('active-wall');
          wallMode = false;
          phase = 'move';
          placeWallBtn.disabled = true;
          currentPlayer = 1 - currentPlayer;
          updateStatus();
          checkGameEnd();
        }
      }
    }

    function placePiece(sq, player) {
      const piece = document.createElement('div');
      piece.className = 'piece';
      piece.style.background = player.color;
      piece.dataset.player = player.id;
      sq.appendChild(piece);
      player.pieces.push(sq);
    }

    function movePiece(fromSq, toSq) {
      const piece = fromSq.querySelector('.piece');
      if (!piece) return;
      toSq.appendChild(piece);
      // Update player's piece reference
      const player = players[currentPlayer];
      player.pieces = player.pieces.map(s => (s === fromSq ? toSq : s));
    }

    function isValidMove(fromSq, toSq) {
      // Only squares, not occupied, not through wall, not diagonal, 1 or 2 spaces, L-shape allowed
      if (toSq.querySelector('.piece')) return false;
      const fr = +fromSq.dataset.row, fc = +fromSq.dataset.col;
      const tr = +toSq.dataset.row, tc = +toSq.dataset.col;
      const dr = Math.abs(fr - tr), dc = Math.abs(fc - tc);
      if ((dr === 0 && (dc === 4 || dc === 2)) || (dc === 0 && (dr === 4 || dr === 2)) || (dr === 2 && dc === 4) || (dr === 4 && dc === 2)) {
        // Check for walls and pieces in path
        return !isBlocked(fromSq, toSq);
      }
      return false;
    }

    function isBlocked(fromSq, toSq) {
      // Check for walls or pieces in the path
      const fr = +fromSq.dataset.row, fc = +fromSq.dataset.col;
      const tr = +toSq.dataset.row, tc = +toSq.dataset.col;
      // Only straight or L-shape
      if (fr === tr) {
        // Horizontal
        const minC = Math.min(fc, tc);
        const maxC = Math.max(fc, tc);
        for (let c = minC + 2; c <= maxC; c += 2) {
          const midSq = getSquare(fr, c);
          if (midSq && midSq.querySelector('.piece')) return true;
          const wallCol = c - 1;
          const wall = getWall(fr, wallCol);
          if (wall && wall.dataset.active === 'true') return true;
        }
      } else if (fc === tc) {
        // Vertical
        const minR = Math.min(fr, tr);
        const maxR = Math.max(fr, tr);
        for (let r = minR + 2; r <= maxR; r += 2) {
          const midSq = getSquare(r, fc);
          if (midSq && midSq.querySelector('.piece')) return true;
          const wallRow = r - 1;
          const wall = getWall(wallRow, fc);
          if (wall && wall.dataset.active === 'true') return true;
        }
      } else {
        // L-shape: must check both legs
        // Try both legs
        const leg1 = !isBlocked(fromSq, getSquare(fr, tc));
        const leg2 = !isBlocked(getSquare(fr, tc), toSq);
        const leg3 = !isBlocked(fromSq, getSquare(tr, fc));
        const leg4 = !isBlocked(getSquare(tr, fc), toSq);
        return !(leg1 && leg2) && !(leg3 && leg4);
      }
      return false;
    }

    function getSquare(row, col) {
      return squares.find(sq => +sq.dataset.row === row && +sq.dataset.col === col);
    }
    function getWall(row, col) {
      return walls.find(w => +w.dataset.row === row && +w.dataset.col === col);
    }
    function isAdjacentWall(sq, wall) {
      const sr = +sq.dataset.row, sc = +sq.dataset.col;
      const wr = +wall.dataset.row, wc = +wall.dataset.col;
      return (Math.abs(sr - wr) + Math.abs(sc - wc)) === 1;
    }
    function highlightMoves(sq) {
      clearHighlights();
      squares.forEach(target => {
        if (isValidMove(sq, target)) {
          target.classList.add('highlight');
        }
      });
    }
    function clearHighlights() {
      squares.forEach(sq => sq.classList.remove('highlight'));
    }
    function updateStatus() {
      if (phase === 'placement') {
        gameStatus.textContent = `${players[currentPlayer].name}'s turn to place a piece.`;
      } else if (phase === 'move') {
        gameStatus.textContent = `${players[currentPlayer].name}'s turn to move.`;
      } else if (phase === 'wall') {
        gameStatus.textContent = `${players[currentPlayer].name}: Place a wall adjacent to your piece.`;
      } else if (phase === 'end') {
        gameStatus.textContent = winner ? `${winner} wins!` : 'Game over!';
      }
    }
    function checkGameEnd() {
      // End if no moves or all pieces enclosed
      // For simplicity, just check if any player can move
      let canMove = false;
      players.forEach(player => {
        player.pieces.forEach(sq => {
          squares.forEach(target => {
            if (isValidMove(sq, target)) canMove = true;
          });
        });
      });
      if (!canMove) {
        phase = 'end';
        winner = calculateWinner();
        updateStatus();
      }
    }
    function calculateWinner() {
      // For now, just count accessible area for each piece
      function floodFill(sq, visited) {
        const key = sq.dataset.square;
        if (visited.has(key)) return 0;
        visited.add(key);
        let area = 1;
        const dirs = [
          [0, 2], [0, -2], [2, 0], [-2, 0]
        ];
        for (const [dr, dc] of dirs) {
          const nr = +sq.dataset.row + dr;
          const nc = +sq.dataset.col + dc;
          const nextSq = getSquare(nr, nc);
          if (nextSq && !nextSq.querySelector('.piece')) {
            // Check wall between
            const wall = getWall((+sq.dataset.row + nr) / 2, (+sq.dataset.col + nc) / 2);
            if (wall && wall.dataset.active === 'false') {
              area += floodFill(nextSq, visited);
            }
          }
        }
        return area;
      }
      const areas = players.map(player =>
        player.pieces.reduce((sum, sq) => sum + floodFill(sq, new Set()), 0)
      );
      if (areas[0] > areas[1]) return players[0].name;
      if (areas[1] > areas[0]) return players[1].name;
      return 'Draw';
    }
    updateStatus();
  </script>
</body>
</html>
